# PyTorch-NEAT è®­ç»ƒæµç¨‹è¯¦è§£

æœ¬æ–‡æ¡£è¯¦ç»†è§£é‡Šä¸‰ç§ç½‘ç»œçš„è®­ç»ƒæµç¨‹ã€CPPNæœºåˆ¶ã€è¾“å…¥è¾“å‡ºè®¾è®¡å’ŒVMASç¯å¢ƒé€‚é…ã€‚

---

## ğŸ“‹ ç›®å½•

1. [è®­ç»ƒæµç¨‹æ€»è§ˆ](#è®­ç»ƒæµç¨‹æ€»è§ˆ)
2. [åŸºå› ç»„è¯¦è§£](#åŸºå› ç»„è¯¦è§£)
3. [CPPNå®Œæ•´è§£æ](#cppnå®Œæ•´è§£æ)
4. [åæ ‡è®¾è®¡åŸç†](#åæ ‡è®¾è®¡åŸç†)
5. [è¾“å…¥è¾“å‡ºè®¾è®¡æŒ‡å—](#è¾“å…¥è¾“å‡ºè®¾è®¡æŒ‡å—)
6. [VMASç¯å¢ƒé€‚é…](#vmasç¯å¢ƒé€‚é…)

---

## è®­ç»ƒæµç¨‹æ€»è§ˆ

### ğŸ”„ NEATè®­ç»ƒå¾ªç¯

```
å¼€å§‹
  â†“
åˆ›å»ºåˆå§‹ç§ç¾¤ï¼ˆéšæœºåŸºå› ç»„ï¼‰
  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¸–ä»£å¾ªç¯ (Generation Loop)  â”‚
â”‚                             â”‚
â”‚  1. åŸºå› ç»„ â†’ ç½‘ç»œè½¬æ¢        â”‚
â”‚  2. è¯„ä¼°é€‚åº”åº¦              â”‚
â”‚  3. é€‰æ‹©çˆ¶ä»£                â”‚
â”‚  4. äº¤å‰å˜å¼‚                â”‚
â”‚  5. ç‰©ç§åˆ’åˆ†                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†“
è¾¾åˆ°ç»ˆæ­¢æ¡ä»¶ï¼Ÿ
  â†“
è¿”å›æœ€ä½³åŸºå› ç»„
```

### ğŸ¯ ä¸‰ç§ç½‘ç»œçš„è®­ç»ƒæµç¨‹å¯¹æ¯”

| é˜¶æ®µ | RecurrentNet | AdaptiveLinearNet | AdaptiveNet |
|------|-------------|-------------------|-------------|
| **åŸºå› ç»„è¡¨ç¤º** | ç›´æ¥ç¼–ç æƒé‡ | ç¼–ç CPPN | ç¼–ç 6ä¸ªCPPN |
| **ç½‘ç»œåˆ›å»º** | æå–æƒé‡ â†’ çŸ©é˜µ | åŸºå› ç»„ â†’ CPPN â†’ åˆå§‹æƒé‡ | åŸºå› ç»„ â†’ 6ä¸ªCPPN â†’ å¤šä¸ªæƒé‡çŸ©é˜µ |
| **å‰å‘ä¼ æ’­** | æ ‡å‡†RNN | çº¿æ€§å±‚ + æƒé‡æ›´æ–° | RNN + æƒé‡æ›´æ–° |
| **è¯„ä¼°** | è¿è¡Œepisodeè·å¾—å¥–åŠ± | è¿è¡Œepisodeè·å¾—å¥–åŠ± | è¿è¡Œepisodeè·å¾—å¥–åŠ± |
| **è¿›åŒ–å¯¹è±¡** | æƒé‡å€¼ | CPPNçš„æ‹“æ‰‘å’Œæƒé‡ | 6ä¸ªCPPNçš„å…±äº«æ‹“æ‰‘å’Œæƒé‡ |

---

## åŸºå› ç»„è¯¦è§£

### ğŸ“¦ NEATåŸºå› ç»„ç»“æ„

NEATåŸºå› ç»„åŒ…å«ä¸¤éƒ¨åˆ†ï¼š

```python
genome = {
    'nodes': {
        node_id: {
            'bias': float,        # åç½®
            'response': float,    # å“åº”ç³»æ•°
            'activation': str,    # æ¿€æ´»å‡½æ•°å
            'aggregation': str    # èšåˆå‡½æ•°å
        }
    },
    'connections': {
        (in_id, out_id): {
            'weight': float,      # è¿æ¥æƒé‡
            'enabled': bool       # æ˜¯å¦æ¿€æ´»
        }
    }
}
```

### ğŸ”€ ç›´æ¥ç¼–ç  vs CPPNç¼–ç 

#### 1ï¸âƒ£ RecurrentNet - ç›´æ¥ç¼–ç 

**åŸºå› ç»„ â†’ ç½‘ç»œçš„è½¬æ¢**ï¼š

```python
# æ­¥éª¤1ï¼šåŸºå› ç»„å®šä¹‰ç½‘ç»œæ‹“æ‰‘
genome.nodes = {
    -1: input1,
    -2: input2,
    0: hidden1,
    1: output1
}

genome.connections = {
    (-1, 0): weight=0.5,   # input1 â†’ hidden1
    (-2, 0): weight=-0.3,  # input2 â†’ hidden1
    (0, 1): weight=1.2,    # hidden1 â†’ output1
}

# æ­¥éª¤2ï¼šæå–æƒé‡å¡«å……çŸ©é˜µ
W_ih = [[0.5, -0.3]]  # è¾“å…¥â†’éšè—
W_ho = [[1.2]]        # éšè—â†’è¾“å‡º

# æ­¥éª¤3ï¼šåˆ›å»ºRecurrentNet
net = RecurrentNet(
    input_to_hidden=W_ih,
    hidden_to_output=W_ho,
    ...
)
```

**ç‰¹ç‚¹**ï¼š
- âœ… ç®€å•ç›´æ¥ï¼Œæ¯ä¸ªæƒé‡æ˜¯ä¸€ä¸ªåŸºå› 
- âŒ å‚æ•°é‡å¤§ï¼Œæœç´¢ç©ºé—´å¤§
- âœ… è¡Œä¸ºå¯é¢„æµ‹

#### 2ï¸âƒ£ AdaptiveLinearNet - CPPNé—´æ¥ç¼–ç 

**åŸºå› ç»„ â†’ CPPN â†’ ç½‘ç»œæƒé‡çš„è½¬æ¢**ï¼š

```python
# æ­¥éª¤1ï¼šåŸºå› ç»„å®šä¹‰CPPNç½‘ç»œ
genome.nodes = {
    -1: x_in_leaf,
    -2: y_in_leaf,
    -3: x_out_leaf,
    -4: y_out_leaf,
    -5: pre_leaf,
    -6: post_leaf,
    -7: w_leaf,
    0: hidden_node,
    1: delta_w_output  # CPPNçš„è¾“å‡º
}

genome.connections = {
    (-1, 0): weight=0.8,   # x_in â†’ hidden
    (-3, 0): weight=-0.5,  # x_out â†’ hidden
    (0, 1): weight=1.0,    # hidden â†’ delta_w
}

# æ­¥éª¤2ï¼šåŸºå› ç»„ â†’ CPPN
cppn = create_cppn(
    genome, config,
    leaf_names=['x_in', 'y_in', 'x_out', 'y_out', 'pre', 'post', 'w'],
    node_names=['delta_w']
)

# æ­¥éª¤3ï¼šä½¿ç”¨CPPNç”Ÿæˆåˆå§‹æƒé‡çŸ©é˜µ
for i, out_coord in enumerate(output_coords):
    for j, in_coord in enumerate(input_coords):
        # ä¸ºæ¯ä¸ªè¿æ¥è°ƒç”¨CPPN
        weight[i, j] = cppn(
            x_in=in_coord[0],
            y_in=in_coord[1],
            x_out=out_coord[0],
            y_out=out_coord[1],
            pre=0, post=0, w=0
        )

# æ­¥éª¤4ï¼šåˆ›å»ºAdaptiveLinearNet
net = AdaptiveLinearNet(
    delta_w_node=cppn,  # ä¿å­˜CPPNç”¨äºæƒé‡æ›´æ–°
    input_coords=input_coords,
    output_coords=output_coords,
    ...
)
```

**ç‰¹ç‚¹**ï¼š
- âœ… å‚æ•°æ•ˆç‡é«˜ï¼ˆCPPNå°ï¼Œç”Ÿæˆæƒé‡å¤šï¼‰
- âœ… åˆ©ç”¨ç©ºé—´è§„å¾‹æ€§
- âŒ éœ€è¦è®¾è®¡åæ ‡
- âœ… å¯ä»¥å®ç°å¯¹ç§°ç­‰å‡ ä½•ç‰¹æ€§

#### 3ï¸âƒ£ AdaptiveNet - å¤šCPPNç¼–ç 

**ä¸€ä¸ªåŸºå› ç»„ç¼–ç 6ä¸ªCPPN**ï¼š

```python
# æ­¥éª¤1ï¼šåŸºå› ç»„å®šä¹‰ä¸€ä¸ªå¤§CPPNç½‘ç»œ
# æœ‰7ä¸ªè¾“å…¥èŠ‚ç‚¹ï¼Œ6ä¸ªè¾“å‡ºèŠ‚ç‚¹
genome.output_keys = [1, 2, 3, 4, 5, 6]  # 6ä¸ªè¾“å‡º

# æ­¥éª¤2ï¼šåˆ†ç¦»æˆ6ä¸ªCPPN
nodes = create_cppn(
    genome, config,
    leaf_names=['x_in', 'y_in', 'x_out', 'y_out', 'pre', 'post', 'w'],
    node_names=['w_ih', 'b_h', 'w_hh', 'b_o', 'w_ho', 'delta_w']
)

cppn_w_ih = nodes[0]     # ç”Ÿæˆè¾“å…¥â†’éšè—æƒé‡
cppn_b_h = nodes[1]      # ç”Ÿæˆéšè—å±‚åç½®
cppn_w_hh = nodes[2]     # ç”Ÿæˆéšè—â†’éšè—åˆå§‹æƒé‡
cppn_b_o = nodes[3]      # ç”Ÿæˆè¾“å‡ºå±‚åç½®
cppn_w_ho = nodes[4]     # ç”Ÿæˆéšè—â†’è¾“å‡ºæƒé‡
cppn_delta_w = nodes[5]  # ç”Ÿæˆæƒé‡æ›´æ–°è§„åˆ™

# æ­¥éª¤3ï¼šä½¿ç”¨6ä¸ªCPPNç”Ÿæˆæ‰€æœ‰æƒé‡çŸ©é˜µ
# ï¼ˆè¿‡ç¨‹ç±»ä¼¼AdaptiveLinearNetï¼Œä½†æœ‰6ä¸ªæƒé‡çŸ©é˜µï¼‰

# æ­¥éª¤4ï¼šåˆ›å»ºAdaptiveNet
net = AdaptiveNet(
    w_ih_node=cppn_w_ih,
    b_h_node=cppn_b_h,
    # ... å…¶ä»–CPPN
    delta_w_node=cppn_delta_w,
    ...
)
```

**ç‰¹ç‚¹**ï¼š
- âœ… æœ€å¼ºå¤§çš„è¡¨è¾¾èƒ½åŠ›
- âœ… 6ä¸ªCPPNå…±äº«åŸºå› ç»„ï¼ŒååŒè¿›åŒ–
- âŒ æœ€å¤æ‚
- âŒ è®­ç»ƒæœ€æ…¢

---

## CPPNå®Œæ•´è§£æ

### ğŸ§  CPPNæ˜¯ä»€ä¹ˆï¼Ÿ

**CPPN (Compositional Pattern Producing Networks) = ç»„åˆæ¨¡å¼ç”Ÿæˆç½‘ç»œ**

CPPNæ˜¯ä¸€ä¸ª**ç‰¹æ®Šç”¨é€”çš„ç¥ç»ç½‘ç»œ**ï¼Œå®ƒä¸æ˜¯ç”¨æ¥å¤„ç†ä»»åŠ¡çš„ï¼Œè€Œæ˜¯ç”¨æ¥**ç”Ÿæˆæƒé‡**çš„ã€‚

#### ğŸ” å…³é”®ç†è§£

```
æ™®é€šç¥ç»ç½‘ç»œï¼š
è¾“å…¥ï¼ˆç¯å¢ƒçŠ¶æ€ï¼‰â†’ ç¥ç»ç½‘ç»œ â†’ è¾“å‡ºï¼ˆåŠ¨ä½œï¼‰

CPPNï¼š
è¾“å…¥ï¼ˆåæ ‡ã€æ¿€æ´»å€¼ï¼‰â†’ CPPN â†’ è¾“å‡ºï¼ˆæƒé‡å€¼æˆ–æƒé‡æ›´æ–°é‡ï¼‰
```

### ğŸ“Š CPPNçš„è¾“å…¥è¾“å‡º

#### CPPNçš„7ä¸ªè¾“å…¥

```python
cppn_inputs = {
    'x_in': è¾“å…¥ç¥ç»å…ƒçš„xåæ ‡,    # ä¾‹å¦‚: -1.0
    'y_in': è¾“å…¥ç¥ç»å…ƒçš„yåæ ‡,    # ä¾‹å¦‚: 0.0
    'x_out': è¾“å‡ºç¥ç»å…ƒçš„xåæ ‡,   # ä¾‹å¦‚: 1.0
    'y_out': è¾“å‡ºç¥ç»å…ƒçš„yåæ ‡,   # ä¾‹å¦‚: 1.0
    'pre': è¾“å…¥ç¥ç»å…ƒçš„æ¿€æ´»å€¼,    # ä¾‹å¦‚: 0.8ï¼ˆå‰å‘ä¼ æ’­æ—¶ï¼‰
    'post': è¾“å‡ºç¥ç»å…ƒçš„æ¿€æ´»å€¼,   # ä¾‹å¦‚: 0.3ï¼ˆå‰å‘ä¼ æ’­æ—¶ï¼‰
    'w': å½“å‰çš„è¿æ¥æƒé‡å€¼          # ä¾‹å¦‚: 0.5ï¼ˆå‰å‘ä¼ æ’­æ—¶ï¼‰
}
```

#### CPPNçš„è¾“å‡º

**AdaptiveLinearNet**: 1ä¸ªè¾“å‡º
```python
cppn_output = delta_w  # æƒé‡æ›´æ–°é‡
```

**AdaptiveNet**: 6ä¸ªè¾“å‡º
```python
cppn_outputs = {
    'w_ih': è¾“å…¥â†’éšè—çš„æƒé‡,
    'b_h': éšè—å±‚åç½®,
    'w_hh': éšè—â†’éšè—çš„åˆå§‹æƒé‡,
    'b_o': è¾“å‡ºå±‚åç½®,
    'w_ho': éšè—â†’è¾“å‡ºçš„æƒé‡,
    'delta_w': éšè—â†’éšè—çš„æƒé‡æ›´æ–°é‡
}
```

### ğŸ”„ CPPNçš„å®Œæ•´å·¥ä½œæµç¨‹

#### é˜¶æ®µ1ï¼šåˆå§‹åŒ–ï¼ˆä½¿ç”¨CPPNç”Ÿæˆåˆå§‹æƒé‡ï¼‰

```python
# AdaptiveLinearNetçš„åˆå§‹åŒ–
net = AdaptiveLinearNet.create(genome, config, input_coords, output_coords)

# å†…éƒ¨æµç¨‹ï¼š
def reset(self):
    # 1. ä¸ºæ¯å¯¹(è¾“å…¥ç¥ç»å…ƒ, è¾“å‡ºç¥ç»å…ƒ)è°ƒç”¨CPPN
    for i, out_coord in enumerate(output_coords):
        for j, in_coord in enumerate(input_coords):
            # 2. å‡†å¤‡CPPNè¾“å…¥ï¼ˆåˆå§‹åŒ–æ—¶æ¿€æ´»å€¼éƒ½æ˜¯0ï¼‰
            x_in = in_coord[0]      # ä¾‹å¦‚: -1.0
            y_in = in_coord[1]      # ä¾‹å¦‚: 0.0
            x_out = out_coord[0]    # ä¾‹å¦‚: 1.0
            y_out = out_coord[1]    # ä¾‹å¦‚: 1.0
            pre = 0.0               # åˆå§‹åŒ–æ—¶ä¸º0
            post = 0.0              # åˆå§‹åŒ–æ—¶ä¸º0
            w = 0.0                 # åˆå§‹åŒ–æ—¶ä¸º0
            
            # 3. è°ƒç”¨CPPNç”Ÿæˆåˆå§‹æƒé‡
            initial_weight = cppn(
                x_in=x_in, y_in=y_in,
                x_out=x_out, y_out=y_out,
                pre=pre, post=post, w=w
            )
            
            # 4. ä¿å­˜åˆ°æƒé‡çŸ©é˜µ
            W[i, j] = initial_weight
    
    # 5. åº”ç”¨é˜ˆå€¼åŒ–ï¼ˆç¨€ç–åŒ–ï¼‰
    W[abs(W) < threshold] = 0
```

#### é˜¶æ®µ2ï¼šå‰å‘ä¼ æ’­ï¼ˆä½¿ç”¨CPPNæ›´æ–°æƒé‡ï¼‰

```python
# æ¯ä¸ªæ—¶é—´æ­¥çš„å‰å‘ä¼ æ’­
def activate(self, inputs):
    # 1. ä½¿ç”¨å½“å‰æƒé‡è®¡ç®—è¾“å‡º
    outputs = activation(W @ inputs)
    
    # 2. å‡†å¤‡CPPNè¾“å…¥ï¼ˆç°åœ¨æœ‰çœŸå®çš„æ¿€æ´»å€¼ï¼‰
    for i, out_coord in enumerate(output_coords):
        for j, in_coord in enumerate(input_coords):
            x_in = in_coord[0]
            y_in = in_coord[1]
            x_out = out_coord[0]
            y_out = out_coord[1]
            pre = inputs[j]         # è¾“å…¥ç¥ç»å…ƒçš„æ¿€æ´»å€¼
            post = outputs[i]       # è¾“å‡ºç¥ç»å…ƒçš„æ¿€æ´»å€¼
            w = W[i, j]             # å½“å‰æƒé‡å€¼
            
            # 3. è°ƒç”¨CPPNè®¡ç®—æƒé‡æ›´æ–°é‡
            delta_w = cppn(
                x_in=x_in, y_in=y_in,
                x_out=x_out, y_out=y_out,
                pre=pre, post=post, w=w
            )
            
            # 4. æ›´æ–°æƒé‡ï¼ˆä»…åœ¨è¡¨è¾¾çš„è¿æ¥ä¸Šï¼‰
            if W_expressed[i, j]:
                W[i, j] += delta_w
    
    # 5. é™åˆ¶æƒé‡åœ¨åˆç†èŒƒå›´
    W = clip(W, -weight_max, weight_max)
    
    return outputs
```

### ğŸ’¡ CPPNçš„è®¾è®¡ç›´è§‰

#### ä¸ºä»€ä¹ˆä½¿ç”¨åæ ‡ï¼Ÿ

```
åæ ‡ç¼–ç äº†ç¥ç»å…ƒä¹‹é—´çš„ç©ºé—´å…³ç³»ï¼

ä¾‹å¦‚åœ¨T-Mazeä¸­ï¼š
- å·¦ä¼ æ„Ÿå™¨ [-1, 0] â†” å·¦åŠ¨ä½œ [-1, 1]ï¼šè·ç¦»è¿‘ï¼Œå¯èƒ½æƒé‡å¤§
- å³ä¼ æ„Ÿå™¨ [1, 0] â†” å·¦åŠ¨ä½œ [-1, 1]ï¼šè·ç¦»è¿œï¼Œå¯èƒ½æƒé‡å°
```

CPPNå¯ä»¥å­¦ä¼šåˆ©ç”¨è¿™ç§å‡ ä½•è§„å¾‹æ€§ï¼š
- **å¯¹ç§°æ€§**ï¼šå·¦å³å¯¹ç§°çš„åæ ‡äº§ç”Ÿç›¸ä¼¼çš„æƒé‡
- **è·ç¦»ä¾èµ–**ï¼šè·ç¦»è¿‘çš„ç¥ç»å…ƒè¿æ¥æ›´å¼º
- **å±€éƒ¨æ€§**ï¼šç›¸é‚»çš„ç¥ç»å…ƒç›¸äº’å½±å“

#### ä¸ºä»€ä¹ˆä½¿ç”¨æ¿€æ´»å€¼ï¼Ÿ

```
æ¿€æ´»å€¼è®©æƒé‡æ›´æ–°å…·æœ‰"å­¦ä¹ "èƒ½åŠ›ï¼

Hebbianå­¦ä¹ è§„åˆ™: Î”w = Î· Ã— pre Ã— post
- å¦‚æœè¾“å…¥å’Œè¾“å‡ºåŒæ—¶æ¿€æ´» â†’ å¢å¼ºè¿æ¥
- å¦‚æœä¸åŒæ—¶æ¿€æ´» â†’ å‰Šå¼±è¿æ¥
```

CPPNå¯ä»¥å®ç°æ›´å¤æ‚çš„è§„åˆ™ï¼š
```
delta_w = CPPN(åæ ‡, pre, post, w)
```

è¿™æ¯”å›ºå®šçš„Hebbianè§„åˆ™æ›´çµæ´»ï¼Œå¯ä»¥å­¦åˆ°ä»»åŠ¡ç‰¹å®šçš„æ›´æ–°è§„åˆ™ã€‚

---

## åæ ‡è®¾è®¡åŸç†

### ğŸ¨ ä¸ºä»€ä¹ˆéœ€è¦åæ ‡ï¼Ÿ

åæ ‡æ˜¯**ç©ºé—´ç¼–ç **çš„ä¸€ç§æ–¹å¼ï¼Œç”¨äºå‘Šè¯‰CPPNç¥ç»å…ƒä¹‹é—´çš„å‡ ä½•å…³ç³»ã€‚

#### æ²¡æœ‰åæ ‡ï¼ˆRecurrentNetï¼‰
```
ç¥ç»å…ƒåªæœ‰ID: input1, input2, hidden1, output1
NEATå¿…é¡»è¿›åŒ–æ¯ä¸€ä¸ªè¿æ¥çš„æƒé‡
```

#### æœ‰åæ ‡ï¼ˆAdaptiveLinearNet/AdaptiveNetï¼‰
```
ç¥ç»å…ƒæœ‰ä½ç½®: input1[-1,0], input2[0,0], output1[0,1]
CPPNå¯ä»¥åˆ©ç”¨ä½ç½®å…³ç³»ç”Ÿæˆæƒé‡
å‚æ•°æ•ˆç‡æ›´é«˜
```

### ğŸ“ åæ ‡è®¾è®¡å®ä¾‹è¯¦è§£

#### ç¤ºä¾‹ï¼šT-Mazeä»»åŠ¡

```python
# T-Mazeç¯å¢ƒçš„è§‚æµ‹
observation = [
    wall_left,    # å·¦ä¾§æ˜¯å¦æœ‰å¢™ï¼ˆ0æˆ–1ï¼‰
    wall_front,   # å‰æ–¹æ˜¯å¦æœ‰å¢™ï¼ˆ0æˆ–1ï¼‰
    wall_right,   # å³ä¾§æ˜¯å¦æœ‰å¢™ï¼ˆ0æˆ–1ï¼‰
    color         # é¢œè‰²æç¤ºï¼ˆå¥–åŠ±åœ¨å·¦è¿˜æ˜¯å³ï¼‰
]

# åŠ¨ä½œ
actions = [
    turn_left,    # å·¦è½¬
    go_forward,   # å‰è¿›
    turn_right    # å³è½¬
]
```

#### åæ ‡è®¾è®¡

```python
input_coords = [
    [-1.0, 0.0],  # è¾“å…¥1ï¼šå·¦ä¾§å¢™å£ä¼ æ„Ÿå™¨
    [0.0, 0.0],   # è¾“å…¥2ï¼šå‰æ–¹å¢™å£ä¼ æ„Ÿå™¨
    [1.0, 0.0],   # è¾“å…¥3ï¼šå³ä¾§å¢™å£ä¼ æ„Ÿå™¨
    [0.0, -1.0]   # è¾“å…¥4ï¼šé¢œè‰²ä¼ æ„Ÿå™¨ï¼ˆç‰¹æ®Šä½ç½®ï¼‰
]

output_coords = [
    [-1.0, 0.0],  # è¾“å‡º1ï¼šå·¦è½¬åŠ¨ä½œ
    [0.0, 0.0],   # è¾“å‡º2ï¼šå‰è¿›åŠ¨ä½œ
    [1.0, 0.0]    # è¾“å‡º3ï¼šå³è½¬åŠ¨ä½œ
]
```

#### è®¾è®¡åŸç†

```
1ï¸âƒ£ æ°´å¹³æ’åˆ—ä¼ æ„Ÿå™¨ï¼ˆy=0ï¼‰
   [-1, 0]        [0, 0]        [1, 0]
   å·¦ä¼ æ„Ÿå™¨       å‰ä¼ æ„Ÿå™¨      å³ä¼ æ„Ÿå™¨
   
   â†’ åæ˜ äº†ç‰©ç†ä¼ æ„Ÿå™¨çš„ç©ºé—´æ’åˆ—

2ï¸âƒ£ é¢œè‰²ä¼ æ„Ÿå™¨ç‰¹æ®Šä½ç½®ï¼ˆy=-1ï¼‰
   [0, -1]
   é¢œè‰²ä¼ æ„Ÿå™¨
   
   â†’ ä¸åŒäºå¢™å£ä¼ æ„Ÿå™¨ï¼Œyåæ ‡ä¸åŒè¡¨ç¤ºè¯­ä¹‰ä¸åŒ

3ï¸âƒ£ æ°´å¹³æ’åˆ—åŠ¨ä½œï¼ˆy=0ï¼Œä¸ä¼ æ„Ÿå™¨åŒå±‚ï¼‰
   [-1, 0]        [0, 0]        [1, 0]
   å·¦è½¬           å‰è¿›          å³è½¬
   
   â†’ ä¸ä¼ æ„Ÿå™¨å¯¹é½ï¼Œåˆ©ç”¨å‡ ä½•å¯¹åº”

4ï¸âƒ£ æœŸæœ›çš„CPPNè¡Œä¸º
   å·¦ä¼ æ„Ÿå™¨[-1,0] â†’ å·¦è½¬[-1,0]: è·ç¦»=0ï¼Œå¯èƒ½å¼ºè¿æ¥
   å·¦ä¼ æ„Ÿå™¨[-1,0] â†’ å³è½¬[1,0]:  è·ç¦»=2ï¼Œå¯èƒ½å¼±è¿æ¥
   å³ä¼ æ„Ÿå™¨[1,0]  â†’ å³è½¬[1,0]:  è·ç¦»=0ï¼Œå¯èƒ½å¼ºè¿æ¥
   
   é¢œè‰²[0,-1] â†’ å·¦è½¬[-1,0]: éœ€è¦å­¦ä¹ ï¼ˆè®°å¿†ä»»åŠ¡ï¼‰
   é¢œè‰²[0,-1] â†’ å³è½¬[1,0]:  éœ€è¦å­¦ä¹ ï¼ˆè®°å¿†ä»»åŠ¡ï¼‰
```

### ğŸ¯ åæ ‡è®¾è®¡æŒ‡å—

#### åŸåˆ™1ï¼šåæ˜ è¯­ä¹‰å…³ç³»

```python
# âœ… å¥½çš„è®¾è®¡ï¼šä¼ æ„Ÿå™¨æŒ‰æ–¹å‘æ’åˆ—
input_coords = [
    [-1, 0],  # å·¦
    [0, 0],   # ä¸­
    [1, 0]    # å³
]

# âŒ ä¸å¥½çš„è®¾è®¡ï¼šéšæœºæ’åˆ—
input_coords = [
    [0.3, -0.7],  # æ²¡æœ‰æ˜ç¡®è¯­ä¹‰
    [-0.2, 0.5],
    [0.8, 0.1]
]
```

#### åŸåˆ™2ï¼šåˆ©ç”¨å¯¹ç§°æ€§

```python
# å¦‚æœä»»åŠ¡æœ‰å¯¹ç§°æ€§ï¼Œåæ ‡ä¹Ÿåº”è¯¥å¯¹ç§°
# ä¾‹å¦‚ï¼Œå·¦å³å¯¹ç§°çš„ä»»åŠ¡
input_coords = [
    [-1, 0],  # å·¦ä¼ æ„Ÿå™¨
    [0, 0],   # ä¸­é—´ä¼ æ„Ÿå™¨
    [1, 0]    # å³ä¼ æ„Ÿå™¨ï¼ˆä¸å·¦ä¼ æ„Ÿå™¨å¯¹ç§°ï¼‰
]

output_coords = [
    [-1, 0],  # å·¦åŠ¨ä½œ
    [1, 0]    # å³åŠ¨ä½œï¼ˆå¯¹ç§°ï¼‰
]
```

#### åŸåˆ™3ï¼šä½¿ç”¨ä¸åŒçš„yåæ ‡åŒºåˆ†ç±»åˆ«

```python
# åŒºåˆ†ä¸åŒç±»å‹çš„è¾“å…¥
input_coords = [
    [-1, 0], [0, 0], [1, 0],  # å¢™å£ä¼ æ„Ÿå™¨ï¼ˆy=0ï¼‰
    [0, -1]                    # é¢œè‰²ä¼ æ„Ÿå™¨ï¼ˆy=-1ï¼Œä¸åŒç±»å‹ï¼‰
]

# æˆ–è€…ä½¿ç”¨å¤šå±‚ç»“æ„
input_coords = [
    [-1, 0], [0, 0], [1, 0],   # ç¬¬ä¸€å±‚ï¼šç©ºé—´è¾“å…¥
    [-1, 1], [0, 1], [1, 1]    # ç¬¬äºŒå±‚ï¼šæ—¶é—´è¾“å…¥
]
```

#### åŸåˆ™4ï¼šèŒƒå›´é€šå¸¸åœ¨[-2, 2]

```python
# âœ… å¥½çš„èŒƒå›´
coords = [[-1, 0], [0, 0], [1, 0]]  # åœ¨[-1, 1]èŒƒå›´å†…

# âš ï¸ å¯ä»¥ä½†ä¸å¸¸è§
coords = [[-2, -2], [0, 0], [2, 2]]  # æ›´å¤§èŒƒå›´

# âŒ é¿å…è¿‡å¤§çš„å€¼
coords = [[-10, 0], [0, 0], [10, 0]]  # å¯èƒ½å¯¼è‡´CPPNè¡Œä¸ºä¸ç¨³å®š
```

### ğŸ”¬ å®éªŒï¼šåæ ‡è®¾è®¡çš„å½±å“

```python
# å®éªŒ1ï¼šç´§å‡‘æ’åˆ— vs ç¨€ç–æ’åˆ—
design1 = [[-0.5, 0], [0, 0], [0.5, 0]]   # ç´§å‡‘
design2 = [[-2, 0], [0, 0], [2, 0]]       # ç¨€ç–

# ç»“æœï¼šç´§å‡‘æ’åˆ—é€šå¸¸æ›´å¥½ï¼ˆç¥ç»å…ƒé—´è·å°ï¼Œå®¹æ˜“å»ºç«‹è¿æ¥ï¼‰

# å®éªŒ2ï¼šå¯¹ç§° vs ä¸å¯¹ç§°
design1 = [[-1, 0], [0, 0], [1, 0]]       # å¯¹ç§°
design2 = [[-1, 0], [0.3, 0], [0.8, 0]]   # ä¸å¯¹ç§°

# ç»“æœï¼šå¯¹ç§°è®¾è®¡åœ¨å¯¹ç§°ä»»åŠ¡ä¸Šæ€§èƒ½æ›´å¥½

# å®éªŒ3ï¼šè¯­ä¹‰å¯¹é½ vs éšæœº
design1 = [  # è¯­ä¹‰å¯¹é½
    [-1, 0],  # å·¦ä¼ æ„Ÿå™¨
    [-1, 1]   # å·¦åŠ¨ä½œï¼ˆxåæ ‡å¯¹é½ï¼‰
]
design2 = [  # éšæœº
    [-1, 0],  # å·¦ä¼ æ„Ÿå™¨
    [1, 1]    # å³åŠ¨ä½œï¼ˆä¸å¯¹é½ï¼‰
]

# ç»“æœï¼šè¯­ä¹‰å¯¹é½æ›´å®¹æ˜“å­¦ä¹ 
```

---

## è¾“å…¥è¾“å‡ºè®¾è®¡æŒ‡å—

### ğŸ“¥ ç½‘ç»œè¾“å…¥è®¾è®¡

#### 1. ç¡®å®šè§‚æµ‹ç»´åº¦

```python
# ä¾‹å¦‚ï¼šCartPole
env = gym.make('CartPole-v1')
obs = env.reset()[0]
print(obs.shape)  # (4,)

# è§‚æµ‹åŒ…å«ï¼š
# obs[0]: å°è½¦ä½ç½®
# obs[1]: å°è½¦é€Ÿåº¦
# obs[2]: æ†è§’åº¦
# obs[3]: æ†è§’é€Ÿåº¦
```

#### 2. è®¾è®¡è¾“å…¥åæ ‡ï¼ˆå¯¹äºè‡ªé€‚åº”ç½‘ç»œï¼‰

```python
# æ–¹å¼1ï¼šçº¿æ€§æ’åˆ—ï¼ˆæœ€ç®€å•ï¼‰
input_coords = [
    [-1.5, 0],  # obs[0]
    [-0.5, 0],  # obs[1]
    [0.5, 0],   # obs[2]
    [1.5, 0]    # obs[3]
]

# æ–¹å¼2ï¼šæŒ‰è¯­ä¹‰åˆ†ç»„
input_coords = [
    [-1, 0],    # ä½ç½®
    [-1, 1],    # é€Ÿåº¦ï¼ˆä¸ä½ç½®å¯¹é½ä½†åœ¨ä¸åŒå±‚ï¼‰
    [1, 0],     # è§’åº¦
    [1, 1]      # è§’é€Ÿåº¦ï¼ˆä¸è§’åº¦å¯¹é½ä½†åœ¨ä¸åŒå±‚ï¼‰
]

# æ–¹å¼3ï¼š2Dç©ºé—´å¸ƒå±€
input_coords = [
    [-1, 0],    # å·¦ä¾§ä¿¡æ¯
    [1, 0],     # å³ä¾§ä¿¡æ¯
    [0, -1],    # åº•éƒ¨ä¿¡æ¯
    [0, 1]      # é¡¶éƒ¨ä¿¡æ¯
]
```

### ğŸ“¤ ç½‘ç»œè¾“å‡ºè®¾è®¡

#### 1. ç¡®å®šåŠ¨ä½œç»´åº¦

```python
# ç¦»æ•£åŠ¨ä½œç©ºé—´
env.action_space  # Discrete(2) â†’ 2ä¸ªåŠ¨ä½œ

# è¿ç»­åŠ¨ä½œç©ºé—´
env.action_space  # Box(-1, 1, (2,)) â†’ 2ç»´è¿ç»­åŠ¨ä½œ
```

#### 2. è®¾è®¡è¾“å‡ºåæ ‡

```python
# ç¦»æ•£åŠ¨ä½œï¼ˆå¦‚å·¦/å³ï¼‰
output_coords = [
    [-1, 0],    # åŠ¨ä½œ0ï¼šå·¦
    [1, 0]      # åŠ¨ä½œ1ï¼šå³
]

# å¤šä¸ªç¦»æ•£åŠ¨ä½œ
output_coords = [
    [-1, 0],    # åŠ¨ä½œ0ï¼šå·¦è½¬
    [0, 0],     # åŠ¨ä½œ1ï¼šå‰è¿›
    [1, 0]      # åŠ¨ä½œ2ï¼šå³è½¬
]

# è¿ç»­åŠ¨ä½œï¼ˆ2ç»´ï¼‰
output_coords = [
    [0, 0],     # åŠ¨ä½œç»´åº¦0
    [0, 1]      # åŠ¨ä½œç»´åº¦1
]
```

#### 3. åŠ¨ä½œè½¬æ¢å‡½æ•°

```python
# å¯¹äºRecurrentNetå’Œè‡ªé€‚åº”ç½‘ç»œï¼Œéœ€è¦è½¬æ¢è¾“å‡ºä¸ºåŠ¨ä½œ

# ç¤ºä¾‹1ï¼šäºŒåˆ†ç±»ï¼ˆCartPoleï¼‰
def activate_net(net, states):
    outputs = net.activate(states)  # (batch_size, 1)
    actions = (outputs[:, 0] > 0.5).astype(int)  # é˜ˆå€¼0.5
    return actions

# ç¤ºä¾‹2ï¼šå¤šåˆ†ç±»ï¼ˆT-Mazeï¼‰
def activate_net(net, states):
    outputs = net.activate(states)  # (batch_size, 3)
    actions = outputs.argmax(axis=1)  # é€‰æ‹©æœ€å¤§å€¼çš„ç´¢å¼•
    return actions

# ç¤ºä¾‹3ï¼šè¿ç»­åŠ¨ä½œ
def activate_net(net, states):
    outputs = net.activate(states)  # (batch_size, 2)
    actions = np.tanh(outputs)  # é™åˆ¶åœ¨[-1, 1]
    return actions
```

### ğŸ¯ å®Œæ•´ç¤ºä¾‹ï¼šT-Maze

```python
# 1. ç¯å¢ƒè§‚æµ‹
"""
T-Mazeè§‚æµ‹ç©ºé—´ï¼š
- obs[0]: å·¦ä¾§æœ‰å¢™ï¼Ÿ (0æˆ–1)
- obs[1]: å‰æ–¹æœ‰å¢™ï¼Ÿ (0æˆ–1)
- obs[2]: å³ä¾§æœ‰å¢™ï¼Ÿ (0æˆ–1)
- obs[3]: é¢œè‰²æç¤º (0-1ä¹‹é—´çš„å€¼)
"""

# 2. è¾“å…¥åæ ‡è®¾è®¡
input_coords = [
    [-1.0, 0.0],   # obs[0] å·¦å¢™ï¼šæ”¾åœ¨å·¦ä¾§
    [0.0, 0.0],    # obs[1] å‰å¢™ï¼šæ”¾åœ¨ä¸­é—´
    [1.0, 0.0],    # obs[2] å³å¢™ï¼šæ”¾åœ¨å³ä¾§
    [0.0, -1.0]    # obs[3] é¢œè‰²ï¼šç‰¹æ®Šä½ç½®ï¼ˆä¸åŒyåæ ‡ï¼‰
]

# è®¾è®¡ç†ç”±ï¼š
# - å‰ä¸‰ä¸ªæŒ‰ç©ºé—´ä½ç½®æ’åˆ—ï¼ˆå·¦-ä¸­-å³ï¼‰
# - é¢œè‰²ä¼ æ„Ÿå™¨åœ¨ä¸åŒyåæ ‡ï¼Œè¡¨ç¤ºå®ƒæ˜¯ä¸åŒç±»å‹çš„è¾“å…¥
# - y=0è¡¨ç¤ºå¢™å£ä¼ æ„Ÿå™¨ï¼Œy=-1è¡¨ç¤ºé¢œè‰²ä¼ æ„Ÿå™¨

# 3. åŠ¨ä½œç©ºé—´
"""
T-MazeåŠ¨ä½œç©ºé—´ï¼š
- action=0: å·¦è½¬
- action=1: å‰è¿›
- action=2: å³è½¬
"""

# 4. è¾“å‡ºåæ ‡è®¾è®¡
output_coords = [
    [-1.0, 0.0],   # action=0 å·¦è½¬ï¼šæ”¾åœ¨å·¦ä¾§
    [0.0, 0.0],    # action=1 å‰è¿›ï¼šæ”¾åœ¨ä¸­é—´
    [1.0, 0.0]     # action=2 å³è½¬ï¼šæ”¾åœ¨å³ä¾§
]

# è®¾è®¡ç†ç”±ï¼š
# - ä¸è¾“å…¥ä¼ æ„Ÿå™¨åœ¨åŒä¸€yåæ ‡ï¼ˆy=0ï¼‰
# - ç©ºé—´å¯¹é½ï¼šå·¦ä¼ æ„Ÿå™¨[-1,0] å¯¹åº” å·¦è½¬[-1,0]
# - æœŸæœ›CPPNå­¦åˆ°ï¼šå·¦ä¼ æ„Ÿå™¨æœ‰å¢™ â†’ ä¸è¦å·¦è½¬

# 5. åˆ›å»ºç½‘ç»œ
net = AdaptiveLinearNet.create(
    genome, config,
    input_coords=input_coords,
    output_coords=output_coords,
    batch_size=4
)

# 6. åŠ¨ä½œé€‰æ‹©å‡½æ•°
def activate_net(net, states):
    """
    states: (batch_size, 4) çš„numpyæ•°ç»„
    returns: (batch_size,) çš„æ•´æ•°æ•°ç»„ï¼Œå€¼ä¸º0/1/2
    """
    outputs = net.activate(states)  # (batch_size, 3)
    actions = outputs.argmax(axis=1)  # é€‰æœ€å¤§çš„
    return actions.numpy()

# 7. è¯„ä¼°å¾ªç¯
for step in range(max_steps):
    # å‰å‘ä¼ æ’­
    actions = activate_net(net, states)
    
    # ç¯å¢ƒäº¤äº’
    next_states, rewards, dones, truncated, infos = env.step(actions)
    
    # ç´¯ç§¯å¥–åŠ±
    total_rewards += rewards
    
    # æ›´æ–°çŠ¶æ€
    states = next_states
```

---

## VMASç¯å¢ƒé€‚é…

### ğŸ¤– VMASç®€ä»‹

**VMAS (Vectorized Multi-Agent System)** æ˜¯ä¸€ä¸ªå¤šæ™ºèƒ½ä½“å¼ºåŒ–å­¦ä¹ ç¯å¢ƒã€‚

ç‰¹ç‚¹ï¼š
- ğŸ”¢ **å‘é‡åŒ–**ï¼šåŒæ—¶è¿è¡Œå¤šä¸ªç¯å¢ƒå®ä¾‹
- ğŸ‘¥ **å¤šæ™ºèƒ½ä½“**ï¼šæ¯ä¸ªç¯å¢ƒæœ‰å¤šä¸ªæ™ºèƒ½ä½“
- ğŸ® **å¤šç§åœºæ™¯**ï¼šwaterfall, transport, balanceç­‰

### ğŸ“Š VMASä¸å•æ™ºèƒ½ä½“ç¯å¢ƒçš„åŒºåˆ«

| ç»´åº¦ | å•æ™ºèƒ½ä½“ï¼ˆGymï¼‰ | å¤šæ™ºèƒ½ä½“ï¼ˆVMASï¼‰ |
|------|----------------|-----------------|
| **è§‚æµ‹** | (obs_dim,) | (n_agents, obs_dim) |
| **åŠ¨ä½œ** | (action_dim,) | (n_agents, action_dim) |
| **å¥–åŠ±** | scalar | (n_agents,) |
| **ç½‘ç»œ** | 1ä¸ªç½‘ç»œ | 1ä¸ªç½‘ç»œï¼ˆå‚æ•°å…±äº«ï¼‰æˆ–nä¸ªç½‘ç»œ |

### ğŸ”„ VMASé€‚é…æ­¥éª¤

#### æ­¥éª¤1ï¼šç†è§£VMASè§‚æµ‹

```python
import vmas

env = vmas.make_env(
    scenario="waterfall",
    num_envs=4,           # 4ä¸ªå¹¶è¡Œç¯å¢ƒ
    num_agents=3,         # æ¯ä¸ªç¯å¢ƒ3ä¸ªæ™ºèƒ½ä½“
    continuous_actions=True,
    device="cpu"
)

obs = env.reset()
print(obs.shape)  # (4, 3, obs_dim)
                  # (num_envs, n_agents, obs_dim)
```

#### æ­¥éª¤2ï¼šè®¾è®¡ç½‘ç»œç»“æ„

**æ–¹æ¡ˆAï¼šå‚æ•°å…±äº«ï¼ˆæ¨èï¼‰**

```python
# æ‰€æœ‰æ™ºèƒ½ä½“å…±äº«ä¸€ä¸ªç½‘ç»œ
# ä¼˜ç‚¹ï¼šå‚æ•°å°‘ï¼Œè®­ç»ƒå¿«ï¼Œæ³›åŒ–å¥½
# ç¼ºç‚¹ï¼šæ™ºèƒ½ä½“è¡Œä¸ºç›¸åŒ

# ç½‘ç»œè¾“å…¥ï¼šå•ä¸ªæ™ºèƒ½ä½“çš„è§‚æµ‹
# ç½‘ç»œè¾“å‡ºï¼šå•ä¸ªæ™ºèƒ½ä½“çš„åŠ¨ä½œ

def make_net(genome, config, batch_size):
    # batch_size = num_envs * n_agents
    net = RecurrentNet.create(
        genome, config,
        batch_size=batch_size,  # 4 * 3 = 12
        activation=tanh_activation
    )
    return net
```

**æ–¹æ¡ˆBï¼šç‹¬ç«‹ç½‘ç»œ**

```python
# æ¯ä¸ªæ™ºèƒ½ä½“æœ‰è‡ªå·±çš„ç½‘ç»œ
# ä¼˜ç‚¹ï¼šæ™ºèƒ½ä½“å¯ä»¥æœ‰ä¸åŒç­–ç•¥
# ç¼ºç‚¹ï¼šå‚æ•°å¤šï¼Œè®­ç»ƒæ…¢

class MultiAgentNet:
    def __init__(self, genomes, config, n_agents, batch_size):
        self.nets = [
            RecurrentNet.create(g, config, batch_size)
            for g in genomes[:n_agents]
        ]
    
    def activate(self, obs):
        # obs: (batch_size, n_agents, obs_dim)
        actions = []
        for i, net in enumerate(self.nets):
            agent_obs = obs[:, i, :]  # (batch_size, obs_dim)
            agent_action = net.activate(agent_obs)
            actions.append(agent_action)
        return torch.stack(actions, dim=1)  # (batch_size, n_agents, action_dim)
```

#### æ­¥éª¤3ï¼šé€‚é…activateå‡½æ•°

```python
def activate_net(net, obs):
    """
    Args:
        net: ç¥ç»ç½‘ç»œ
        obs: (num_envs, n_agents, obs_dim) çš„è§‚æµ‹
        
    Returns:
        actions: (num_envs, n_agents, action_dim) çš„åŠ¨ä½œ
    """
    num_envs, n_agents, obs_dim = obs.shape
    
    # æ–¹æ³•1ï¼šreshapeæˆ2Dï¼ˆå‚æ•°å…±äº«ï¼‰
    obs_flat = obs.reshape(num_envs * n_agents, obs_dim)
    actions_flat = net.activate(obs_flat)
    actions = actions_flat.reshape(num_envs, n_agents, -1)
    
    # æ–¹æ³•2ï¼šå¾ªç¯å¤„ç†æ¯ä¸ªæ™ºèƒ½ä½“ï¼ˆç‹¬ç«‹ç½‘ç»œï¼‰
    # actions = []
    # for i in range(n_agents):
    #     agent_obs = obs[:, i, :]
    #     agent_action = nets[i].activate(agent_obs)
    #     actions.append(agent_action)
    # actions = torch.stack(actions, dim=1)
    
    return actions
```

#### æ­¥éª¤4ï¼šå®Œæ•´çš„VMASè®­ç»ƒç¤ºä¾‹

```python
# examples/vmas/train_vmas.py

import vmas
import neat
from pytorch_neat.recurrent_net import RecurrentNet
from pytorch_neat.multi_env_eval import MultiEnvEvaluator

# 1. é…ç½®
scenario = "waterfall"
num_envs = 4
n_agents = 3
max_steps = 100

# 2. åˆ›å»ºç¯å¢ƒ
def make_env():
    return vmas.make_env(
        scenario=scenario,
        num_envs=1,  # MultiEnvEvaluatorä¼šåˆ›å»ºå¤šä¸ª
        num_agents=n_agents,
        continuous_actions=True,
        device="cpu"
    )

# 3. ç½‘ç»œåˆ›å»ºï¼ˆå‚æ•°å…±äº«ï¼‰
def make_net(genome, config, batch_size):
    # batch_size = num_envs * n_agents
    return RecurrentNet.create(
        genome, config,
        batch_size=batch_size * n_agents,
        activation=tanh_activation
    )

# 4. åŠ¨ä½œé€‰æ‹©
def activate_net(net, obs):
    """
    obs: (batch_size, n_agents, obs_dim)
    returns: (batch_size, n_agents, action_dim)
    """
    batch_size, n_agents, obs_dim = obs.shape
    
    # Reshape: (batch_size, n_agents, obs_dim) â†’ (batch_size*n_agents, obs_dim)
    obs_flat = obs.reshape(batch_size * n_agents, obs_dim)
    
    # ç½‘ç»œå‰å‘ä¼ æ’­
    actions_flat = net.activate(obs_flat)
    
    # Reshapeå›æ¥: (batch_size*n_agents, action_dim) â†’ (batch_size, n_agents, action_dim)
    action_dim = actions_flat.shape[1]
    actions = actions_flat.reshape(batch_size, n_agents, action_dim)
    
    # é™åˆ¶åœ¨[-1, 1]
    actions = torch.tanh(actions)
    
    return actions

# 5. è¯„ä¼°å™¨
evaluator = MultiEnvEvaluator(
    make_net,
    activate_net,
    make_env=make_env,
    batch_size=num_envs,
    max_env_steps=max_steps
)

# 6. NEATè®­ç»ƒ
config = neat.Config(...)
pop = neat.Population(config)

def eval_genomes(genomes, config):
    for _, genome in genomes:
        genome.fitness = evaluator.eval_genome(genome, config)

winner = pop.run(eval_genomes, n_generations=100)
```

### ğŸ¯ ä¸‰ç§ç½‘ç»œåœ¨VMASä¸Šçš„ä½¿ç”¨

#### âœ… RecurrentNet - æœ€å®¹æ˜“é€‚é…

```python
# ä¼˜ç‚¹ï¼š
# - ç›´æ¥å¯ç”¨ï¼Œæ— éœ€ä¿®æ”¹
# - è®­ç»ƒå¿«é€Ÿ
# - é€‚åˆå‚æ•°å…±äº«

# ç¼ºç‚¹ï¼š
# - æ— è‡ªé€‚åº”èƒ½åŠ›
# - æ™ºèƒ½ä½“é—´æ— é€šä¿¡æœºåˆ¶

# æ¨èåœºæ™¯ï¼š
# - ç®€å•çš„å¤šæ™ºèƒ½ä½“ä»»åŠ¡
# - å¿«é€ŸåŸå‹éªŒè¯
```

#### âš ï¸ AdaptiveLinearNet - éœ€è¦è®¾è®¡åæ ‡

```python
# ä¼˜ç‚¹ï¼š
# - è‡ªé€‚åº”èƒ½åŠ›
# - å¯ä»¥å­¦ä¹ æ™ºèƒ½ä½“é—´åè°ƒ

# ç¼ºç‚¹ï¼š
# - éœ€è¦è®¾è®¡åˆç†çš„åæ ‡
# - å¯¹äºé«˜ç»´è§‚æµ‹ç©ºé—´è¾ƒå›°éš¾

# åæ ‡è®¾è®¡ç¤ºä¾‹ï¼ˆwaterfallåœºæ™¯ï¼‰:
# å‡è®¾æ¯ä¸ªæ™ºèƒ½ä½“è§‚æµ‹: [è‡ªå·±ä½ç½®x, è‡ªå·±ä½ç½®y, ç›®æ ‡ä½ç½®x, ç›®æ ‡ä½ç½®y]

input_coords = [
    [-1, 0],   # è‡ªå·±ä½ç½®x
    [-1, 1],   # è‡ªå·±ä½ç½®y
    [1, 0],    # ç›®æ ‡ä½ç½®x
    [1, 1]     # ç›®æ ‡ä½ç½®y
]

output_coords = [
    [-1, 0],   # xæ–¹å‘åŠ¨ä½œ
    [1, 0]     # yæ–¹å‘åŠ¨ä½œ
]

# æ¨èåœºæ™¯ï¼š
# - éœ€è¦çŸ­æœŸè®°å¿†çš„å¤šæ™ºèƒ½ä½“ä»»åŠ¡
# - è§‚æµ‹ç»´åº¦ä¸å¤ªé«˜ï¼ˆ<10ï¼‰
```

#### âœ… AdaptiveNet - æœ€å¼ºå¤§ä½†æœ€æ…¢

```python
# ä¼˜ç‚¹ï¼š
# - æœ€å¼ºçš„è¡¨è¾¾èƒ½åŠ›
# - å¯ä»¥å­¦ä¹ å¤æ‚çš„åè°ƒç­–ç•¥

# ç¼ºç‚¹ï¼š
# - è®­ç»ƒæœ€æ…¢
# - åæ ‡è®¾è®¡æ›´å¤æ‚ï¼ˆéœ€è¦è®¾è®¡éšè—å±‚åæ ‡ï¼‰

# æ¨èåœºæ™¯ï¼š
# - å¤æ‚çš„å¤šæ™ºèƒ½ä½“åè°ƒä»»åŠ¡
# - ç ”ç©¶é¡¹ç›®
```

### ğŸ“‹ VMASå®Œæ•´é…ç½®ç¤ºä¾‹

```python
# vmas_config.yaml
vmas:
  scenario: waterfall
  num_envs: 4
  n_agents: 3
  continuous_actions: true
  max_steps: 100

network:
  type: recurrent  # æˆ– adaptive_linear, adaptive
  activation: tanh
  batch_size: 12  # num_envs * n_agents
  device: cpu
  
  # å¦‚æœä½¿ç”¨è‡ªé€‚åº”ç½‘ç»œ
  input_coords: [[-1, 0], [0, 0], [1, 0], [0, -1]]
  output_coords: [[-1, 0], [1, 0]]

neat:
  pop_size: 150
  fitness_threshold: 10.0
  n_generations: 500
```

### ğŸš€ è¿è¡ŒVMASè®­ç»ƒ

```bash
# ä½¿ç”¨RecurrentNetï¼ˆæœ€ç®€å•ï¼‰
python examples/vmas/train_vmas.py \
    --scenario waterfall \
    --net_type recurrent \
    --n_generations 500

# ä½¿ç”¨AdaptiveLinearNet
python examples/vmas/train_vmas.py \
    --scenario waterfall \
    --net_type adaptive_linear \
    --n_generations 1000 \
    --input_coords "[[-1,0],[0,0],[1,0],[0,-1]]" \
    --output_coords "[[-1,0],[1,0]]"

# ä½¿ç”¨AdaptiveNet
python examples/vmas/train_vmas.py \
    --scenario waterfall \
    --net_type adaptive \
    --n_generations 2000
```

---

## æ€»ç»“

### ğŸ¯ å…³é”®è¦ç‚¹

1. **è®­ç»ƒæµç¨‹**ï¼š
   - NEATè¿›åŒ–åŸºå› ç»„
   - åŸºå› ç»„è½¬æ¢ä¸ºç½‘ç»œï¼ˆç›´æ¥æˆ–é€šè¿‡CPPNï¼‰
   - ç½‘ç»œåœ¨ç¯å¢ƒä¸­è¯„ä¼°
   - é€‰æ‹©ã€äº¤å‰ã€å˜å¼‚

2. **CPPN**ï¼š
   - æ˜¯ä¸€ä¸ªç”Ÿæˆæƒé‡çš„ç¥ç»ç½‘ç»œ
   - è¾“å…¥ï¼šåæ ‡ã€æ¿€æ´»å€¼ã€å½“å‰æƒé‡
   - è¾“å‡ºï¼šåˆå§‹æƒé‡æˆ–æƒé‡æ›´æ–°é‡
   - åˆ©ç”¨ç©ºé—´è§„å¾‹æ€§

3. **åæ ‡è®¾è®¡**ï¼š
   - åæ˜ è¯­ä¹‰å…³ç³»
   - åˆ©ç”¨å¯¹ç§°æ€§
   - ä½¿ç”¨åˆç†çš„èŒƒå›´
   - æŒ‰ç±»å‹åˆ†å±‚

4. **VMASé€‚é…**ï¼š
   - âœ… ä¸‰ç§ç½‘ç»œéƒ½å¯ä»¥ç”¨äºVMAS
   - æ¨èä»RecurrentNetå¼€å§‹ï¼ˆå‚æ•°å…±äº«ï¼‰
   - éœ€è¦å¤„ç†3Då¼ é‡ï¼š(num_envs, n_agents, dim)
   - å…³é”®æ˜¯æ­£ç¡®çš„reshapeæ“ä½œ

### ğŸ“š è¿›ä¸€æ­¥å­¦ä¹ 

æŸ¥çœ‹ï¼š
- `examples/adaptive/main.py` - AdaptiveLinearNetå®Œæ•´ç¤ºä¾‹
- `examples/simple/main.py` - RecurrentNetå®Œæ•´ç¤ºä¾‹  
- `examples/vmas/train_vmas.py` - VMASé€‚é…ç¤ºä¾‹
- `pytorch_neat/cppn.py` - CPPNå®ç°ç»†èŠ‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2025-01-21  
**ä½œè€…**: PyTorch-NEAT Team

